package penTest.meide;

import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Main1 {
    class Point{
        int x;
        int y;
    }

    public ArrayList<ArrayList<Integer>> generate (int numRows) {
        // write code here
        ArrayList<ArrayList<Integer>> res = new ArrayList<ArrayList<Integer>>();
        for (int i = 0; i < numRows; i++) {
            ArrayList<Integer> row = new ArrayList<Integer>();
            for (int j = 0; j <= i; j++) {
                if (j==0||j==i){
                    row.add(1);
                }else {
                    row.add(res.get(i-1).get(j-1)+res.get(i-1).get(j));
                }
            }
            res.add(row);
        }
        return res;
    }
    public int maxPointsNum (Point[] points) {
        // write code here
        int len = points.length;
        if (len < 3){
            return len;
        }
        int count = 0;

        HashMap<Double, Integer> map = new HashMap<Double, Integer>();
        for (int i = 0; i < len; i++) {
            map.clear();
            int same=1;
            if (count >= len-i || count>len/2){
                break;
            }
            Point cur = points[i];
            for (int j = 0; j < len; j++) {
                if (i==j){
                    continue;
                }
                double slope = Integer.MAX_VALUE;
                Point next = points[j];
                if (cur.x == next.x && cur.y==next.y){
                    same++;
                    continue;
                }else if (cur.x == next.x){
                    //求两点的斜率
                    slope = Integer.MAX_VALUE;

                }else {
                    slope = 1.0*((cur.y - next.y)/(cur.x - next.x));
                }
                map.put(slope, map.containsKey(slope) ? map.get(slope)+1 : 1);
            }
            if (map.keySet().size()==0){
                count = same > count ? same : count;
            }else {
                for (double key:map.keySet()){
                    count = Math.max(same+map.get(key), count);
                }
            }

        }
        return count;
    }
}
