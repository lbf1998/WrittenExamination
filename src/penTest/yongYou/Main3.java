package penTest.yongYou;

import java.util.Arrays;
import java.util.Stack;

public class Main3 {
    public static void main(String[] args) {
        int[] nums = {50, 30, 80, 30, 27, 57};
        int[] building = findBuilding(nums);
        System.out.println(Arrays.toString(building));

    }
    public static int[] findBuilding (int[] heights) {
        // write code here
        int[] nums = new int[heights.length];
        for (int i = 0; i < heights.length; i++) {
            nums[i] = getNums(heights, i) + 1;
        }
        return nums;
    }

    //采用单调递减栈，栈顶元素最小，因为前面楼层低，不会挡住后面；前面高，才会挡住后面，栈顶是最接近当前位置的楼，
    //所以要最小，代表此时栈顶所在位置向某一方向能看到其它楼的楼顶。
    private static int getNums(int[] heights, int index) {
        int max_he = 0;
        Stack<Integer> stack = new Stack<Integer>();
        for (int i = heights.length - 1; i > index; i--) {
            if (isHigh(heights, i, index, "L")){
                stack.push(i);
            }
        }
        max_he = stack.size();
        stack.clear();
        for (int i = 0; i < index; i++) {
            if (isHigh(heights, i, index, "R")){
                stack.push(i);
            }
        }
        max_he += stack.size();
        return max_he;
    }
    //[50, 30, 80, 30, 27, 57]
    private static boolean isHigh(int[] heights, int i, int index, String str) {
        boolean flag = false;
        if (str.equals("L")){
            for (int j = i; j > index; j--) {
                if (heights[i] < heights[j]){
                    return false;
                }
            }
            flag = true;
        }else {
            for (int j = i; j < index; j++) {
                if (heights[i] < heights[j+1]){
                    return false;
                }
            }
            flag = true;
        }
        return flag;
    }
}
